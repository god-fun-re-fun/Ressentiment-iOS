//
//  UIKitTestModel.swift
//  Scene
//
//  Created by Ïù¥Ï°∞ÏùÄ on 3/19/24.
//

import UIKit
import SwiftUI

import AVFoundation
import SceneKit

import CocoaMQTT

class SceneViewController: UIViewController {
    var scene: SCNScene?
    var allowsCameraControl: Bool = false

    override func viewDidLoad() {
        super.viewDidLoad()

        let scnView = SCNView()
        // scnViewÏùò ÌÅ¨Í∏∞Î•º Î∂ÄÎ™® Î∑∞Ïùò 80%Î°ú ÏÑ§Ï†ï
        let viewWidth = self.view.frame.width * 0.25
        let viewHeight = self.view.frame.height * 0.25
        // scnViewÏùò ÌîÑÎ†àÏûÑÏùÑ Í≥ÑÏÇ∞ÌïòÏó¨ Ï§ëÏïôÏóê ÏúÑÏπòÏãúÌÇ¥
        scnView.frame = CGRect(x: 0,
                               y: 0,
                               width: viewWidth+10,
                               height: viewHeight)
        scnView.scene = scene
        scnView.backgroundColor = UIColor.clear
        scnView.allowsCameraControl = allowsCameraControl
        scnView.autoenablesDefaultLighting = true
        self.view.addSubview(scnView)
    }
}

struct SceneViewRepresentable: UIViewControllerRepresentable {
    var scene: SCNScene?
    var allowsCameraControl: Bool

    func makeUIViewController(context: Context) -> SceneViewController {
        let viewController = SceneViewController()
        viewController.scene = scene
        viewController.allowsCameraControl = allowsCameraControl

        let lightNode1 = SCNNode()
        lightNode1.light = SCNLight()
        lightNode1.light?.type = .omni
        lightNode1.position = SCNVector3(x: 0, y: 20, z: 0)
        viewController.scene?.rootNode.addChildNode(lightNode1)

        return viewController
    }

    func updateUIViewController(_ uiViewController: SceneViewController, context: Context) {
        uiViewController.scene = scene
        uiViewController.view.setNeedsLayout()
    }
}

struct MainView: View {
    @State var rotationDuration: TimeInterval = 80.0

    var body: some View {
        VStack {
            TestModelUIkit(rotationDuration: $rotationDuration)
                .edgesIgnoringSafeArea(.all)
                .background(Color.black)
        }
    }
}

struct TestModelUIkit: View {
    @State var glassHead: SCNScene? = SCNScene(named: "GlassHead.scn")
    @State var crackScene = SCNScene(named: "Concrete-Smooth.usdz")

    @State private var timer: Timer? = nil
    @State var velocity: CGFloat = 25
    @Binding var rotationDuration: TimeInterval
    @State var fixPI: CGFloat = .pi*10

    @State var red: CGFloat = 0.5
    @State var green: CGFloat = 0.5
    @State var blue: CGFloat = 0.5
    let alpha: CGFloat = 1.0

    @Environment(\.presentationMode) var presentationMode

    @State private var isSceneViewVisible = true
    @State private var isGIFViewVisible = false

    @State var audioPlayer: AVAudioPlayer?

    @ObservedObject var mqttManager = MQTTManager()

    @State var endPoint = 100
    @State var alphaa: CGFloat = 2
    @State var beta: CGFloat = 100
    @State var gamma: Int = 1

    @StateObject var navigationStackManager = NavigationStackManager()

    var body: some View {
        NavigationStack {
            if navigationStackManager.isAtRootView {
                StartView()
            } else {
                ZStack {
                    if isGIFViewVisible {
                        GIFViewRepresentable(particleColor: UIColor(red: self.red, green: self.green, blue: self.blue, alpha: 1.0))
                            .frame(width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height)
                            .transition(.opacity)
                            .animation(.easeOut(duration: 0.3))
                            .onTapGesture {
                                // ÌòÑÏû¨ Î∑∞ Îã´Í∏∞
                                // presentationMode.wrappedValue.dismiss()
                                navigationStackManager.isAtRootView = true
                            }
                            .onDisappear {
                                stopMusic()
                                timeStop()
                            }
                    } else {
                        SceneView(scene: crackScene, options: [.autoenablesDefaultLighting, .allowsCameraControl])
                            .edgesIgnoringSafeArea(.all)
                            .frame(width: UIScreen.main.bounds.width*2.5, height: UIScreen.main.bounds.height*2.5)
                            .position(x: UIScreen.main.bounds.width/3, y: UIScreen.main.bounds.height/3)
                            .onAppear {
                                setupScene()
                            }
                            .onDisappear {
                                stopMusic()
                                timeStop()
                            }
                            .onReceive(mqttManager.$receivedMessage) { newValue in
                                // Ïó¨Í∏∞Ïóê receivedMessageÍ∞Ä Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ Ïã§ÌñâÌïòÍ≥† Ïã∂ÏùÄ ÏΩîÎìúÎ•º ÏûëÏÑ±Ìï©ÎãàÎã§.
                                // ÏòàÎ•º Îì§Ïñ¥, ÏΩòÏÜîÏóê Î≥ÄÍ≤ΩÎêú Î©îÏãúÏßÄÎ•º Ï∂úÎ†•Ìï©ÎãàÎã§.
                                print("==== Here: \(newValue)")

                                self.timer?.invalidate()
                                self.timer = Timer.scheduledTimer(withTimeInterval: 5.0, repeats: true) { _ in
                                    print("== no event 2 ü´• ==")
                                    rotationAction(glassVector: SCNVector3(1, 0, 0), headVector: SCNVector3(-1, 0, 0))

                                    changeAnimation(0.5, 0.5, 0.5)

                                    self.endPoint -= 1


                                    if endPoint <= 1 {
                                        print("=== The End handleDragChange===")
                                        changeView()
                                    }
                                }

                                receivedMessage(receivedMessage: mqttManager.receivedMessage)
                            }
                            .gesture(
                                DragGesture()
                                    .onChanged { change in
                                        handleDragChange(change: change)

                                        print("==== üîä Duration: \(self.rotationDuration)")
                                    }
                            )
                    }
                    if isSceneViewVisible && !isGIFViewVisible {
                        SceneViewRepresentable(scene: glassHead, allowsCameraControl: true)
                            .frame(width: UIScreen.main.bounds.width / 4, height: UIScreen.main.bounds.height / 4)
                    }
                }
                .animation(.easeOut(duration: 0.3), value: isGIFViewVisible)
            }
        }
        .environmentObject(navigationStackManager)
        .navigationBarBackButtonHidden(true)
    }

    // Î™®Îì† Ï¥àÍ∏∞ ÏÑ§Ï†ïÏùÑ Ï≤òÎ¶¨ÌïòÎäî Ìï®Ïàò
    private func setupScene() {
        // ÏùåÏïÖ Ïû¨ÏÉù Î∞è Ï¥àÍ∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò Ï†ÅÏö©
        self.rotationDuration = 80.0
        self.endPoint = 80

        musicRollingBall()
        applyInitialAnimations()
        receivedMessage(receivedMessage: mqttManager.receivedMessage)
    }

    // Ï¥àÍ∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò Ï†ÅÏö©
    private func applyInitialAnimations() {
        // Ï¥àÍ∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò Ï†ÅÏö© Î°úÏßÅ
        let rotationAction = SCNAction.rotate(by: .pi*15, around: SCNVector3(1, 0, 0), duration: self.rotationDuration)
        let rotationAction2 = SCNAction.rotate(by: .pi*15, around: SCNVector3(-1, 0, 0), duration: self.rotationDuration/2+self.rotationDuration/3)
        glassHead?.rootNode.removeAllActions()
        crackScene?.rootNode.removeAllActions()
        glassHead?.rootNode.runAction(rotationAction)
        crackScene?.rootNode.runAction(rotationAction2)
        changeAnimation(0.5, 0.5, 0.5)
    }

    // MQTT ÌÜµÏã†
    func receivedMessage(receivedMessage: String) {
        if (mqttManager.receivedMessage) == "up" {
            upRotation()
        } else if (mqttManager.receivedMessage) == "down" {
            downRotation()
        } else if (mqttManager.receivedMessage) == "left" {
            rightRotation()
        } else if (mqttManager.receivedMessage) == "right" {
            leftRotation()
        } else if (mqttManager.receivedMessage) == "up-right" {
            upRightRotation()
        } else if (mqttManager.receivedMessage) == "up-left" {
            upLeftRotation()
        } else if (mqttManager.receivedMessage) == "down-right" {
            downRightRotation()
        } else if (mqttManager.receivedMessage) == "down-left" {
            downLeftRotation()
        }

        print("==== endPoint: \(self.endPoint)")

        if endPoint <= 1 {
            print("=== The End Arduino===")
            changeView()
        }
    }

    // ÎìúÎûòÍ∑∏ Ïù¥Î≤§Ìä∏ Ìï∏Îì§ÎßÅ
    private func handleDragChange(change: DragGesture.Value) {
        // ÏÇ¨Ïö©ÏûêÍ∞Ä ÎìúÎûòÍ∑∏Î•º ÏãúÏûëÌïòÎ©¥, ÎìúÎûòÍ∑∏Ïùò Î∞©Ìñ•Í≥º Í±∞Î¶¨Ïóê Îî∞Îùº Ïï†ÎãàÎ©îÏù¥ÏÖòÏùÑ Ï°∞Ï†ïÌï©ÎãàÎã§.
        self.timer?.invalidate()
        self.timer = Timer.scheduledTimer(withTimeInterval: 3.0, repeats: true) { _ in
            print("== no event 1 ü´• ==")
            rotationAction(glassVector: SCNVector3(1, 0, 0), headVector: SCNVector3(-1, 0, 0))

            changeAnimation(0.5, 0.5, 0.5)

            self.endPoint -= Int(beta/self.rotationDuration)

            if endPoint <= 1 {
                print("=== The End handleDragChange===")
                changeView()
            }
        }

        // musicRollingBall()

        if change.translation.height > 0 {
            upRotation()
        } else if change.translation.height < 0 {
            downRotation()
        } else if change.translation.width > 0 {
            rightRotation()
        } else if change.translation.width < 0 {
            leftRotation()
        }

        print("==== endPoint: \(self.endPoint)")

        if endPoint <= 1 {
            print("=== The End TouchEvent===")
            changeView()
        }
    }

    private func timeStop() {
        // ÏÇ¨Ïö©ÏûêÍ∞Ä ÎìúÎûòÍ∑∏Î•º ÎÅùÎÇ¥Î©¥, ÌïÑÏöîÌïú Í≤ΩÏö∞ ÌÉÄÏù¥Î®∏Î•º Ï¥àÍ∏∞ÌôîÌïòÍ±∞ÎÇò, Ïï†ÎãàÎ©îÏù¥ÏÖòÏùÑ Ï†ïÏßÄÌï©ÎãàÎã§.
        self.timer?.invalidate()
        self.timer = nil
        print("=== disappear")
    }

    private func rotationAction(glassVector: SCNVector3, headVector: SCNVector3) {
        let rotationAction = SCNAction.rotate(by: fixPI, around: glassVector, duration: self.rotationDuration)
        let rotationAction2 = SCNAction.rotate(by: fixPI, around: headVector, duration: self.rotationDuration/2+self.rotationDuration/3)
        glassHead?.rootNode.removeAllActions()
        crackScene?.rootNode.removeAllActions()
        glassHead?.rootNode.runAction(rotationAction)
        crackScene?.rootNode.runAction(rotationAction2)
    }

    // ÏúÑÎ°ú ÏõÄÏßÅÏûÑ
    func upRotation() {
        if self.rotationDuration >= 100 {
            self.rotationDuration = 100
        } else {
            self.rotationDuration += alphaa
        }

        self.endPoint -= Int(beta/self.rotationDuration) + Int(beta/self.rotationDuration)

        rotationAction(glassVector: SCNVector3(-1, 0, 0), headVector: SCNVector3(1, 0, 0))
        if (blue <= 0.9) {
            print("===== blue Í∏çÏ†ï ")
            changeAnimation(0.16, 0.52, 0.95)
        } else {
            print("===== blue Î∂ÄÏ†ï ")
            changeAnimation(0.04, 0.12, 0.38)
        }

        print("‚¨ÜÔ∏è veolocity: \(fixPI/self.rotationDuration)  | duration: \(self.rotationDuration)")
    }

    // ÏïÑÎûò ÏõÄÏßÅÏûÑ
    func downRotation() {
        if self.rotationDuration <= 9 {
            self.rotationDuration = 9
        } else {
            self.rotationDuration -= alphaa
        }

        self.endPoint -= Int(beta/(self.rotationDuration))

        rotationAction(glassVector: SCNVector3(1, 0, 0), headVector: SCNVector3(-1, 0, 0))
        if (red <= 0.8) {
            print("===== gray Í∏çÏ†ï ")
            // UIColor(red: 0.92, green: 0.92, blue: 0.92, alpha: 1)
            changeAnimation(0.92, 0.92, 0.92)
        } else {
            print("===== gray Î∂ÄÏ†ï ")
            // UIColor(red: 0.68, green: 0.68, blue: 0.68, alpha: 1)
            changeAnimation(0.68, 0.68, 0.68)
        }

        print("‚¨áÔ∏è veolocity: \(fixPI/self.rotationDuration)  | duration: \(self.rotationDuration)")
    }

    // Ïò§Î•∏Ï™ΩÏúºÎ°ú ÏõÄÏßÅÏûÑ
    func rightRotation() {
        self.endPoint -= Int(beta/self.rotationDuration)

        rotationAction(glassVector: SCNVector3(0, -1, 0), headVector: SCNVector3(0, 1, 0))
        if (green <= 0.85) {
            print("===== green Í∏çÏ†ï ")
            changeAnimation(0.55, 0.92, 0.37)
        } else {
            print("===== green Î∂ÄÏ†ï ")
            changeAnimation(0.24, 0.52, 0.23)
        }

        print("‚û°Ô∏è")
    }

    // ÏôºÏ™ΩÏúºÎ°ú ÏõÄÏßÅÏûÑ
    func leftRotation() {
        self.endPoint -= Int(beta/self.rotationDuration)

        rotationAction(glassVector: SCNVector3(0, 1, 0), headVector: SCNVector3(0, -1, 0))
        if (green <= 0.85) {
            print("===== green Í∏çÏ†ï ")
            changeAnimation(0.55, 0.92, 0.37)
        } else {
            print("===== green Î∂ÄÏ†ï ")
            changeAnimation(0.24, 0.52, 0.23)
        }
        print("‚¨ÖÔ∏è")
    }

    // MARK: - ÎåÄÍ∞ÅÏÑ† ÏõÄÏßÅÏûÑ
    func upLeftRotation() {
        rotationAction(glassVector: SCNVector3(-1, -1, 0), headVector: SCNVector3(1, 1, 0))
    }
    func upRightRotation() {
        rotationAction(glassVector: SCNVector3(-1, 1, 0), headVector: SCNVector3(1, -1, 0))
    }
    func downLeftRotation() {
        rotationAction(glassVector: SCNVector3(1, -1, 0), headVector: SCNVector3(-1, 1, 0))
    }
    func downRightRotation() {
        rotationAction(glassVector: SCNVector3(1, 1, 0), headVector: SCNVector3(-1, -1, 0))
    }

    // view Ï†ÑÌôò Î∞è api post
    func changeView() {
        // print("red: \(self.red) | green: \(self.green) | blue: \(self.blue)")
        self.endPoint = 80
        withAnimation(.easeOut(duration: 0.7)) {
            isGIFViewVisible = true
        }
        isSceneViewVisible = false
        stopMusic()
        RessentimentService().postColor(parameters: ["R":"\(self.red)", "G":"\(self.green)", "B":"\(self.blue)"]) { result in
            switch result {
            case .success(let colorResponse):
                print("=== success: \(colorResponse)")
            case .failure(let error):
                print("API Error: \(error)")
            }
        }
    }

    // ÏùåÏïÖ Play Ìï®Ïàò
    func musicRollingBall() {
        if let bundlePath = Bundle.main.path(forResource: "rollingBall.mp3", ofType: nil),
           let music = URL(string: bundlePath) {
            do {
                audioPlayer = try AVAudioPlayer(contentsOf: music)
                audioPlayer?.prepareToPlay()
                audioPlayer?.play()
                audioPlayer?.numberOfLoops = -1
            } catch {
                print("ÏùåÏïÖ ÌååÏùºÏùÑ Ïû¨ÏÉùÌï† Ïàò ÏóÜÏäµÎãàÎã§.")
            }
        }
    }

    func stopMusic() {
        if audioPlayer?.isPlaying == true {
            audioPlayer?.stop()
            // Ïû¨ÏÉù ÏúÑÏπòÎ•º Ï¥àÍ∏∞Ìôî
            audioPlayer?.currentTime = 0
            print("=== ÏùåÏïÖ Î©àÏ∂§")
        }
    }

    // Ï°∞Î™Ö ÏÉùÏÑ± Ìï®Ïàò
    func createLightNode(color: UIColor, position: SCNVector3) -> SCNNode {
        let light = SCNLight() // Ï°∞Î™Ö Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
        light.type = .omni // Ï†ÑÎ∞©Ìñ• Ï°∞Î™Ö
        light.color = color // Ï°∞Î™ÖÏùò ÏÉâÏÉÅ ÏÑ§Ï†ï

        let lightNode = SCNNode() // Ï°∞Î™Ö ÎÖ∏Îìú ÏÉùÏÑ±
        lightNode.light = light // ÎÖ∏ÎìúÏóê Ï°∞Î™Ö Ï∂îÍ∞Ä
        lightNode.position = position // Ï°∞Î™ÖÏùò ÏúÑÏπò ÏÑ§Ï†ï

        return lightNode
    }

    // ÏÉâÏÉÅ Î≥ÄÍ≤Ω Ìï®Ïàò
    func changeColor(_ goalRed: CGFloat, _ goalGreen: CGFloat, _ goalBlue: CGFloat) -> UIColor {
        // print("=== color change func üé® ===")
        let newRed = self.red + (goalRed - self.red)/velocity
        self.red = newRed
        let newGreen = self.green + (goalGreen - self.green)/velocity
        self.green = newGreen
        let newBlue = self.blue + (goalBlue - self.blue)/velocity
        self.blue = newBlue

        let newColor = UIColor(red: red, green: green, blue: blue, alpha: 1.0)
        return newColor
    }

    // ÏÉâÏÉÅ Î≥ÄÍ≤Ω Î∞òÏòÅÌïòÎ©¥ÏÑú Ïï†ÎãàÎ©îÏù¥ÏÖò Ï†ÅÏö©
    func changeAnimation(_ goalRed: CGFloat, _ goalGreen: CGFloat, _ goalBlue: CGFloat) {
        //print("=== changeAnimation func üìΩÔ∏è ===")
        glassHead?.rootNode.enumerateChildNodes { node, _ in
            node.geometry?.materials.forEach { material in
                // Material_001 Î®∏ÌÖåÎ¶¨ÏñºÎßå Ï∞æÏïÑÏÑú ÏÉâÏÉÅ Î≥ÄÍ≤Ω Ï†ÅÏö©
                if material.name == "Material_001" {

                    let newColor = self.changeColor(goalRed, goalGreen, goalBlue)

                    // SCNTransactionÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Ïï†ÎãàÎ©îÏù¥ÏÖò Ï†ÅÏö©
                    SCNTransaction.begin()
                    SCNTransaction.animationDuration = 0.5 // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏßÄÏÜç ÏãúÍ∞Ñ ÏÑ§Ï†ï
                    material.diffuse.contents = newColor
                    // print("üåÄüåÄnewColor: \(newColor)")
                    SCNTransaction.commit()
                }
            }
        }
    }
}

struct UIKitTestModel_Previews: PreviewProvider {
    static var previews: some View {
        MainView()
    }
}
